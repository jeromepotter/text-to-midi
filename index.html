<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TEXT TO MIDI GENERATOR</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body { 
            background-color: #000000; 
            color: #ffffff; 
            font-family: 'Poppins', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0; 
            padding: 20px;
        }

        .wrapper { 
            width: 100%; 
            max-width: 700px;
            display: flex;
            flex-direction: column;
            height: 90vh; 
        }

        h1 { 
            font-weight: 600; 
            font-size: 1.2rem;
            letter-spacing: 2px; 
            text-align: center; 
            margin-bottom: 10px;
            text-transform: uppercase;
            border-bottom: 1px solid #333;
            padding-bottom: 20px;
        }

        /* --- HOW TO SECTION --- */
        .how-to-toggle {
            text-align: center;
            font-size: 0.7rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 10px;
        }
        .how-to-toggle:hover { color: #fff; }

        .how-to-content {
            display: none;
            background: #111;
            padding: 20px;
            margin-bottom: 15px;
            font-size: 0.8rem;
            line-height: 1.6;
            color: #ccc;
            border: 1px solid #333;
        }
        .how-to-content h3 {
            font-size: 0.8rem;
            color: #fff;
            margin: 15px 0 5px 0;
            text-transform: uppercase;
            border-bottom: 1px dashed #333;
            padding-bottom: 5px;
        }
        .how-to-content h3:first-child { margin-top: 0; }
        
        .how-to-content ul { padding-left: 15px; margin: 0; }
        .how-to-content li { margin-bottom: 8px; }
        
        .prompt-block {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            margin-top: 5px;
            font-family: monospace;
            color: #888;
            font-size: 0.75rem;
        }
        .prompt-title { color: #fff; font-size: 0.75rem; font-weight: bold; margin-top: 10px; display: block; }

        /* --- SETTINGS BAR --- */
        .settings-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }
        .settings-group { flex: 1; }
        
        .settings-label {
            font-size: 0.65rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 8px; 
        }
        
        .api-link { 
            color: #fff; 
            text-decoration: none; 
            cursor: pointer; 
            opacity: 0.5; 
            font-size: 0.65rem;
        }
        .api-link:hover { text-decoration: underline; opacity: 1; }

        .settings-input {
            width: 100%;
            background: #000;
            border: 1px solid #333;
            color: #aaa;
            padding: 8px;
            font-size: 0.8rem;
            font-family: monospace;
            outline: none;
        }
        .settings-input:focus { border-color: #666; color: #fff; }

        /* --- LOG CONSOLE --- */
        #chatContainer {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #222;
            padding: 20px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #050505;
        }
        
        .msg { padding: 10px 15px; font-size: 0.9rem; line-height: 1.5; max-width: 95%; }
        .msg.system { align-self: flex-start; color: #666; font-family: monospace; font-size: 0.75rem; border-left: 2px solid #333; width: 100%; }
        .msg.model { align-self: flex-start; color: #8BE9FD; font-family: monospace; font-size: 0.8rem; border-left: 2px solid #8BE9FD; white-space: pre-wrap; width: 100%; }
        .msg.error { color: #f55; border-color: #f55; }

        /* --- INPUT AREA --- */
        .input-area { position: relative; }
        
        .input-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 5px;
        }
        .input-label { font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 1px; }
        .copy-btn {
            background: none; border: none; color: #444; cursor: pointer;
            font-size: 0.65rem; text-transform: uppercase; padding: 0;
        }
        .copy-btn:hover { color: #fff; }

        textarea { 
            width: 100%; 
            background: #000; 
            border: 1px solid #333; 
            color: #fff; 
            padding: 15px; 
            min-height: 80px;
            max-height: 300px;
            font-size: 0.9rem; 
            font-family: 'Poppins', sans-serif;
            outline: none; 
            resize: vertical;
            display: block;
            box-sizing: border-box;
        }
        textarea:focus { border-color: #fff; }

        .btn-row { display: flex; gap: 10px; margin-top: 10px; }

        button { 
            flex: 1; padding: 15px; 
            background: #000; /* Dark Background */
            color: #fff; /* White Text */
            border: 1px solid #444; 
            font-weight: 600; font-size: 0.9rem; letter-spacing: 1px; 
            text-transform: uppercase; cursor: pointer; 
            transition: all 0.2s ease;
        }
        button:hover { background: #222; border-color: #fff; }
        button:disabled { background: #111 !important; color: #555 !important; border-color: #333 !important; cursor: not-allowed; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; }
    </style>
</head>
<body>

<div class="wrapper">
    <h1>Text to MIDI Generator</h1>
    
    <div class="how-to-toggle" onclick="toggleGuide()">[ HOW TO USE ]</div>
    <div id="guide" class="how-to-content">
        <h3>1. API KEYS</h3>
        Get a key from Google AI Studio. If stuck, reset session or get a new key.
        
        <h3>2. SETUP</h3>
        <ul>
            <li><strong>DAW:</strong> Enable "IAC Driver" (Mac) or "LoopMIDI" (PC). Arm your DAW tracks & Monitor IN.</li>
            <li><strong>HARDWARE:</strong> Connect your MIDI Interface via USB. This tool sends raw MIDI to all 16 channels, perfect for controlling hardware synths (like Juno, Moog, Korg).</li>
        </ul>

        <h3>3. PROMPT EXAMPLES</h3>
        
        <span class="prompt-title">BASIC</span>
        <div class="prompt-block">
            "On Channel 1, play a C Major chord progression. On Channel 2, play a simple melody in C Major."
        </div>

        <span class="prompt-title">INTERMEDIATE</span>
        <div class="prompt-block">
            "On Ch 1 play a funky bassline in A Minor. On Ch 2 play staccato chord stabs on the off-beats. On Ch 10 play a driving 4-on-the-floor beat."
        </div>

        <span class="prompt-title">VIRTUOSO (COMPLEX)</span>
        <div class="prompt-block">
            "You are a virtuosic Bebop Jazz pianist. On Channel 1, play a lightning-fast solo using the 'Coltrane Matrix' chord substitutions. Use chromatic enclosure notes and quintuplet runs. On Channel 2, play sparse, rootless chord voicings (shell voicings) on the off-beats. Crucial: Humanize the velocity. Accented notes should be 110-127, ghost notes should be 30-50. Don't be robotic. The piece should be 20 seconds long."
        </div>
    </div>

    <div class="settings-bar">
        <div class="settings-group">
            <span class="settings-label">
                1. API KEY
                <a href="https://aistudio.google.com/app/apikey" target="_blank" class="api-link">(GET KEY)</a>
            </span>
            <input type="password" id="apiKey" class="settings-input" placeholder="Paste Key Here...">
        </div>
        <div class="settings-group">
            <span class="settings-label">
                2. MIDI OUTPUT
                <span style="opacity: 0.5;">(Select Driver)</span>
            </span>
            <select id="midiOut" class="settings-input"><option>Scanning...</option></select>
        </div>
    </div>

    <div id="chatContainer">
        <div class="msg system">System Ready. Waiting for input...</div>
    </div>

    <div class="input-area">
        <div class="input-header">
            <span class="input-label">Prompt</span>
            <button class="copy-btn" onclick="copyPrompt()">[ COPY PROMPT ]</button>
        </div>
        <textarea id="prompt" placeholder="Describe the music (Instruments, Key, Duration, Vibe)..."></textarea>
        <div class="btn-row">
            <button id="generateBtn" onclick="handleButtonClick()">SEND PROMPT</button>
        </div>
    </div>
</div>

<script>
    let midiOutput = null;
    let loadingInterval = null;
    let isResetState = false; // Tracks if button is in "NEW PROMPT" mode

    function toggleGuide() {
        const guide = document.getElementById('guide');
        const btn = document.querySelector('.how-to-toggle');
        if (getComputedStyle(guide).display === 'none') {
            guide.style.display = 'block';
            btn.innerText = '[ CLOSE GUIDE ]';
        } else {
            guide.style.display = 'none';
            btn.innerText = '[ HOW TO USE ]';
        }
    }

    function copyPrompt() {
        const text = document.getElementById('prompt').value;
        if(text) {
            navigator.clipboard.writeText(text);
            const btn = document.querySelector('.copy-btn');
            const original = btn.innerText;
            btn.innerText = "[ COPIED! ]";
            setTimeout(() => btn.innerText = original, 1500);
        }
    }

    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess().then(access => {
            const outputs = Array.from(access.outputs.values());
            const select = document.getElementById('midiOut');
            select.innerHTML = '';
            
            if (outputs.length === 0) {
                select.innerHTML = '<option value="">No Ports Found</option>';
                return;
            }

            outputs.forEach(port => {
                const option = document.createElement('option');
                option.value = port.id;
                option.text = port.name;
                if (port.name.toLowerCase().includes("iac") || 
                    port.name.toLowerCase().includes("loop")) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            updatePort();
            select.addEventListener('change', updatePort);
        }).catch(e => appendMsg("system error", "MIDI Access Denied: " + e));
    }

    function updatePort() {
        const id = document.getElementById('midiOut').value;
        if (!id) return;
        navigator.requestMIDIAccess().then(a => {
            midiOutput = a.outputs.get(id);
            if (midiOutput) appendMsg("system", `Connected to: ${midiOutput.name}`);
        });
    }

    function appendMsg(role, text) {
        const container = document.getElementById('chatContainer');
        const div = document.createElement('div');
        div.className = `msg ${role}`;
        div.innerText = text;
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    // Handles the single button logic
    function handleButtonClick() {
        if (isResetState) {
            resetSession();
        } else {
            generateMusic();
        }
    }

    function resetSession() {
        document.getElementById('chatContainer').innerHTML = '<div class="msg system">System Ready. Waiting for input...</div>';
        document.getElementById('prompt').value = ""; // Clear Everything
        
        const btn = document.getElementById('generateBtn');
        btn.innerText = "SEND PROMPT";
        isResetState = false;
    }

    function startLoading() {
        let dots = 0;
        const btn = document.getElementById('generateBtn');
        btn.disabled = true;
        
        loadingInterval = setInterval(() => {
            dots = (dots + 1) % 4; 
            let text = "COMPOSING";
            for(let i=0; i<dots; i++) text += ".";
            btn.innerText = text;
        }, 400); 
    }

    function stopLoading(success = false) {
        clearInterval(loadingInterval);
        const btn = document.getElementById('generateBtn');
        
        if (success) {
            btn.innerText = "SUCCESS!";
            btn.style.backgroundColor = "#4CAF50"; // Green
            btn.style.borderColor = "#4CAF50";
            
            // Wait 2s, then switch to "PLAYING..." state (still disabled)
            setTimeout(() => {
                btn.innerText = "PLAYING...";
                btn.style.backgroundColor = "#000";
                btn.style.borderColor = "#444";
                // Button remains disabled until playback finishes in playSequence()
            }, 2000); 
        } else {
            // Error state: revert immediately to allow retry
            btn.innerText = "SEND PROMPT";
            btn.disabled = false;
        }
    }

    // --- NEW HELPER: Remove Comments from JSON String ---
    function cleanAndParseJSON(jsonString) {
        // Remove single line // comments
        let cleaned = jsonString.replace(/\/\/.*$/gm, "");
        // Remove multi-line /* */ comments
        cleaned = cleaned.replace(/\/\*[\s\S]*?\*\//g, "");
        return JSON.parse(cleaned);
    }

    async function generateMusic() {
        const key = document.getElementById('apiKey').value.trim();
        const userPrompt = document.getElementById('prompt').value.trim();
        
        if (!key) return appendMsg("system error", "Please enter API Key.");
        if (!midiOutput) return appendMsg("system error", "Select MIDI Output.");
        if (!userPrompt) return;

        startLoading();

        const systemInstruction = `
        You are a Virtuosic MIDI Composer.
        
        STEP 1: CREATIVE PLAN (REQUIRED)
        Before writing any JSON, you must explain your musical approach. 
        - Describe the rhythmic interaction between channels.
        - Explain how you will avoid repetition (e.g. "I will introduce a new motif at bar 4").
        - Explain how you will ensure the piece lasts the full requested duration.
        
        STEP 2: MIDI DATA
        Output the MIDI data in valid JSON. 
        - DO NOT put comments inside the JSON code block.
        - CRITICAL: Do not simply loop 1 bar. You must write unique variations.
        - CRITICAL: Ensure the last note ends at or after the requested duration.
        - HUMAN FEEL: You are NOT bound to a grid. Use micro-timing (e.g., start_time=1.05 instead of 1.00) for "swing" or "rubato" feels if the prompt requests it.
        - Format: { "tracks": [ { "channel": 1-16, "notes": [ { "pitch": 60, "velocity": 100, "start_time": 0.0, "duration": 1.0 } ] } ] }
        `;

        const payload = {
            contents: [{
                role: "user",
                parts: [{ text: systemInstruction + "\n\nUser Request: " + userPrompt }]
            }]
        };

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error.message || "API Error");
            }

            const data = await response.json();

            // 1. TOKEN COUNT
            if (data.usageMetadata) {
                const tokens = data.usageMetadata.candidatesTokenCount;
                appendMsg("system", `Generated ${tokens} tokens.`);
            }

            const rawText = data.candidates[0].content.parts[0].text;
            
            // 2. PARSE THINKING VS JSON
            const jsonMatch = rawText.match(/\{[\s\S]*\}/);
            
            if (jsonMatch) {
                const jsonIndex = rawText.indexOf(jsonMatch[0]);
                let thoughts = rawText.substring(0, jsonIndex).trim();
                
                // Cleanup Markdown tags
                thoughts = thoughts.replace(/```json/g, "").replace(/```/g, "").trim();

                if (thoughts) {
                    appendMsg("model", thoughts); 
                }
                
                // USE NEW CLEANER FUNCTION
                const musicData = cleanAndParseJSON(jsonMatch[0]);
                
                playSequence(musicData);
                appendMsg("system", "MIDI Sent âœ“");
                stopLoading(true);
            } else {
                appendMsg("model", rawText);
                throw new Error("Model generated text but no valid MIDI JSON.");
            }

        } catch (e) {
            appendMsg("system error", e.message);
            stopLoading(false);
        }
    }

    function playSequence(data) {
        const now = performance.now();
        if (!data.tracks) return;

        let totalNotes = 0;
        let maxDuration = 0;

        data.tracks.forEach(track => {
            const channel = Math.max(0, Math.min(15, (track.channel || 1) - 1));
            track.notes.forEach(note => {
                const start = now + (note.start_time * 1000);
                const end = start + (note.duration * 1000);
                
                if (note.start_time + note.duration > maxDuration) {
                    maxDuration = note.start_time + note.duration;
                }

                midiOutput.send([0x90 + channel, note.pitch, note.velocity || 100], start);
                midiOutput.send([0x80 + channel, note.pitch, 0], end);
                totalNotes++;
            });
        });

        appendMsg("system", `Playing ${maxDuration.toFixed(1)}s sequence...`);

        // Timer for Playback Finish
        setTimeout(() => {
            appendMsg("system", "Playback Finished.");
            
            // SWITCH TO "NEW PROMPT" STATE
            const btn = document.getElementById('generateBtn');
            btn.innerText = "NEW PROMPT";
            btn.disabled = false;
            btn.style.borderColor = "#fff"; // Highlight border slightly
            isResetState = true;
            
        }, maxDuration * 1000);
    }
</script>

</body>
</html>
