<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TEXT TO MIDI GENERATOR</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body { 
            background-color: #000000; 
            color: #ffffff; 
            font-family: 'Poppins', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0; 
            padding: 20px;
        }

        .wrapper { 
            width: 100%; 
            max-width: 700px;
            display: flex;
            flex-direction: column;
            height: 90vh; 
        }

        h1 { 
            font-weight: 600; 
            font-size: 1.2rem;
            letter-spacing: 2px; 
            text-align: center; 
            margin-bottom: 10px;
            text-transform: uppercase;
            border-bottom: 1px solid #333;
            padding-bottom: 20px;
        }

        .how-to-toggle {
            text-align: center;
            font-size: 0.7rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 10px;
        }
        .how-to-toggle:hover { color: #fff; }

        .how-to-content {
            display: none;
            background: #111;
            padding: 20px;
            margin-bottom: 15px;
            font-size: 0.8rem;
            line-height: 1.6;
            color: #ccc;
            border: 1px solid #333;
        }
        .how-to-content h3 {
            font-size: 0.8rem;
            color: #fff;
            margin: 15px 0 5px 0;
            text-transform: uppercase;
            border-bottom: 1px dashed #333;
            padding-bottom: 5px;
        }
        .how-to-content h3:first-child { margin-top: 0; }
        
        .how-to-content ul { padding-left: 15px; margin: 0; }
        .how-to-content li { margin-bottom: 8px; }
        
        .prompt-block {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            margin-top: 5px;
            font-family: monospace;
            color: #888;
            font-size: 0.75rem;
        }
        .prompt-title { color: #fff; font-size: 0.75rem; font-weight: bold; margin-top: 10px; display: block; }

        .settings-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }
        .settings-group { flex: 1; }
        
        .settings-label {
            font-size: 0.65rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 8px; 
        }
        
        .api-link { 
            color: #fff; 
            text-decoration: none; 
            cursor: pointer; 
            opacity: 0.5; 
            font-size: 0.65rem;
        }
        .api-link:hover { text-decoration: underline; opacity: 1; }

        .settings-input {
            width: 100%;
            background: #000;
            border: 1px solid #333;
            color: #aaa;
            padding: 8px;
            font-size: 0.8rem;
            font-family: monospace;
            outline: none;
            box-sizing: border-box;
        }
        .settings-input:focus { border-color: #666; color: #fff; }

        .api-input-wrapper {
            display: flex;
            gap: 5px;
        }

        .api-enter-btn {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            cursor: pointer;
            font-size: 0.7rem;
            padding: 0 15px;
            font-weight: 600;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .api-enter-btn:hover { background: #333; }

        .input-area { 
            position: relative; 
            margin-bottom: 20px; 
        }
        
        .input-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 5px;
        }
        .input-label { font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 1px; }

        .clear-btn {
            background: none; border: none; color: #444; cursor: pointer;
            font-size: 0.65rem; text-transform: uppercase; padding: 0;
        }
        .clear-btn:hover { 
            color: #f55; 
            background: transparent; 
        } 

        textarea { 
            width: 100%; 
            background: #000; 
            border: 1px solid #333; 
            color: #fff; 
            padding: 15px; 
            min-height: 80px;
            max-height: 300px;
            font-size: 0.9rem; 
            font-family: 'Poppins', sans-serif;
            outline: none; 
            resize: vertical;
            display: block;
            box-sizing: border-box;
        }
        textarea:focus { border-color: #fff; }
        
        textarea::placeholder {
            color: #ffffff;
            opacity: 1; 
        }

        .btn-row { display: flex; gap: 10px; margin-top: 10px; }

        button { 
            flex: 1; padding: 15px; 
            background: #000; 
            color: #fff; 
            border: 1px solid #444; 
            font-weight: 600; font-size: 0.9rem; letter-spacing: 1px; 
            text-transform: uppercase; cursor: pointer; 
            transition: all 0.2s ease;
        }
        button:hover { background: #222; border-color: #fff; }
        button:disabled { background: #111 !important; color: #555 !important; border-color: #333 !important; cursor: not-allowed; }

        button.stop-mode {
            background-color: #330000;
            border-color: #ff4444;
            color: #ff4444;
        }
        button.stop-mode:hover {
            background-color: #550000;
            color: #fff;
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            border-top: 1px solid #333;
            padding-top: 15px;
        }

        #chatContainer {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #222;
            padding: 20px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #050505;
        }
        
        .msg { padding: 10px 15px; font-size: 0.9rem; line-height: 1.5; max-width: 95%; }
        
        .msg.system { align-self: flex-start; color: #666; font-family: monospace; font-size: 0.75rem; border-left: 2px solid #333; width: 100%; }
        .msg.model { align-self: flex-start; color: #8BE9FD; font-family: monospace; font-size: 0.8rem; border-left: 2px solid #8BE9FD; white-space: pre-wrap; width: 100%; }
        .msg.user { align-self: flex-end; color: #fff; font-family: 'Poppins', sans-serif; font-size: 0.9rem; border-right: 2px solid #fff; text-align: right; width: auto; max-width: 80%; }
        .msg.error { color: #f55; border-color: #f55; border-left: 2px solid #f55; align-self: flex-start; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; }
    </style>
</head>
<body>

<div class="wrapper">
    <h1>Text to MIDI Generator</h1>
    
    <div class="how-to-toggle" onclick="toggleGuide()">[ HOW TO USE ]</div>
    <div id="guide" class="how-to-content">
        <h3>1. TIPS FOR SUCCESS</h3>
        <ul>
            <li><strong>Duration:</strong> AI works best with shorter loops (under 60s).</li>
            <li><strong>Map Your DAW:</strong> The "Channel" in your prompt must match the "Track" in your DAW. (e.g. If you ask for Piano on Ch 1, make sure Track 1 has a Piano loaded).</li>
            <li><strong>BPM:</strong> Telling the AI the BPM helps it calculate note timing accurately.</li>
        </ul>

        <h3>2. SETUP</h3>
        <ul>
            <li><strong>DAW:</strong> Enable "IAC Driver" (Mac) or "LoopMIDI" (PC). Arm your DAW tracks & Monitor IN.</li>
            <li><strong>HARDWARE:</strong> Connect your MIDI Interface via USB. This tool sends raw MIDI to all 16 channels.</li>
        </ul>

        <h3>3. PROMPT EXAMPLES</h3>
        
        <span class="prompt-title">BASIC</span>
        <div class="prompt-block">
            "On Channel 1, play a C Major chord progression. On Channel 2, play a simple melody in C Major."
        </div>

        <span class="prompt-title">INTERMEDIATE</span>
        <div class="prompt-block">
            "On Ch 1 play a funky bassline in A Minor. On Ch 2 play staccato chord stabs on the off-beats. On Ch 10 play a driving 4-on-the-floor beat."
        </div>

        <span class="prompt-title">VIRTUOSO (JAZZ TRIO)</span>
        <div class="prompt-block">
            "Create a complex Bebop Jazz piece. 220 BPM. Swing feel.
            Ch 1 (Piano): Sparse, rootless 'Bill Evans' style voicings. Syncopated comping.
            Ch 2 (Double Bass): Fast walking bass line with triplet skips.
            Ch 3 (Trumpet): A virtuosic, breathless solo. Use the 'Coltrane Matrix' and chromatic runs.
            Humanize the velocity and timing significantly."
        </div>
    </div>

    <div class="settings-bar">
        <div class="settings-group">
            <span class="settings-label">
                1. API KEY
                <a href="https://aistudio.google.com/app/apikey" target="_blank" class="api-link">(GET KEY)</a>
            </span>
            <div class="api-input-wrapper">
                <input type="password" id="apiKey" class="settings-input" placeholder="Paste Key Here...">
                <button id="apiEnterBtn" class="api-enter-btn" onclick="validateApiKey()">ENTER</button>
            </div>
        </div>
        <div class="settings-group">
            <span class="settings-label">
                2. MIDI OUTPUT
                <span style="opacity: 0.5;">(Select Driver)</span>
            </span>
            <select id="midiOut" class="settings-input"><option>Scanning...</option></select>
        </div>
    </div>

    <div class="input-area">
        <div class="input-header">
            <span class="input-label">Prompt</span>
            <button class="clear-btn" onclick="clearHistory()">[ CLEAR MEMORY ]</button>
        </div>
        <textarea id="prompt" placeholder="Describe the music (Instruments, Key, Duration, Vibe)..."></textarea>
        <div class="btn-row">
            <button id="generateBtn" onclick="handleButtonClick()">GENERATE</button>
        </div>
    </div>

    <div class="chat-header">
        <span class="input-label">RESPONSE LOG</span>
    </div>
    <div id="chatContainer">
        <div class="msg system">System Ready. Waiting for input...</div>
    </div>

</div>

<script>
    let midiOutput = null;
    let loadingInterval = null;
    let isPlaying = false; 
    let schedulerTimerId = null;
    let finishTimeoutId = null;
    let conversationHistory = []; 
    let audioContext = null;
    let processingWorker = null; 

    const LOOKAHEAD_MS = 25;
    const SCHEDULE_AHEAD_TIME = 0.1;

    // --- WORKER CODE (Embedded) ---
    const workerScript = `
        self.onmessage = function(e) {
            const rawJsonString = e.data;
            
            try {
                // 1. Clean and Parse
                const musicData = cleanAndParseJSON(rawJsonString);
                
                // 2. Flatten and Sort Events
                const processedEvents = processTracks(musicData);
                
                // 3. Send back ready-to-play data
                self.postMessage({ type: 'SUCCESS', events: processedEvents, duration: calculateMaxDuration(processedEvents) });
                
            } catch (err) {
                self.postMessage({ type: 'ERROR', message: err.message });
            }
        };

        function calculateMaxDuration(events) {
            if(!events || events.length === 0) return 0;
            return events[events.length - 1].time;
        }

        function processTracks(data) {
            if (!data.tracks) return [];
            const events = [];
            
            data.tracks.forEach(track => {
                const channel = Math.max(0, Math.min(15, (track.channel || 1) - 1));
                
                track.notes.forEach(note => {
                    let pitch = parseInt(note.pitch);
                    if (isNaN(pitch)) pitch = 60; 
                    pitch = Math.max(0, Math.min(127, pitch));

                    let velocity = parseInt(note.velocity || 100);
                    if (isNaN(velocity)) velocity = 100;
                    velocity = Math.max(0, Math.min(127, velocity));

                    const startTime = note.start_time;
                    const duration = note.duration;
                    const endTime = startTime + duration;
                    
                    events.push({
                        time: startTime,
                        message: [0x90 + channel, pitch, velocity]
                    });
                    events.push({
                        time: endTime,
                        message: [0x80 + channel, pitch, 0]
                    });
                });
            });
            
            return events.sort((a, b) => a.time - b.time);
        }

        function cleanAndParseJSON(jsonString) {
            let cleaned = jsonString.replace(/\\/\\/.*$/gm, "");
            cleaned = cleaned.replace(/\\/\\*[\\s\\S]*?\\*\\//g, "");
            cleaned = cleaned.replace(/}\\s*{/g, "}, {");
            cleaned = cleaned.replace(/,\\s*([\\]}])/g, '$1');

            try {
                return JSON.parse(cleaned);
            } catch (e) {
                let stack = [];
                let isString = false;
                for (let i = 0; i < cleaned.length; i++) {
                    const char = cleaned[i];
                    if (char === '"' && cleaned[i-1] !== '\\\\') { isString = !isString; }
                    if (!isString) {
                        if (char === '{') stack.push('}');
                        else if (char === '[') stack.push(']');
                        else if (char === '}' || char === ']') {
                            if (stack.length > 0 && stack[stack.length-1] === char) { stack.pop(); }
                        }
                    }
                }
                while(stack.length > 0) { cleaned += stack.pop(); }
                return JSON.parse(cleaned);
            }
        }
    `;

    const blob = new Blob([workerScript], { type: 'application/javascript' });
    processingWorker = new Worker(URL.createObjectURL(blob));

    processingWorker.onmessage = function(e) {
        if (e.data.type === 'SUCCESS') {
            appendMsg("system", "MIDI Sent âœ“");
            stopLoading(true);
            isPlaying = true;
            playSequence(e.data.events, e.data.duration);
        } else if (e.data.type === 'ERROR') {
            stopLoading(false);
            appendMsg("system error", "Parsing Error: " + e.data.message);
        }
    };

    // ---------------------------------

    async function validateApiKey() {
        const key = document.getElementById('apiKey').value.trim();
        const btn = document.getElementById('apiEnterBtn');
        
        if (!key) {
            flashButton(btn, false);
            return;
        }

        btn.innerText = "CHECKING...";

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
            if (response.ok) {
                flashButton(btn, true);
            } else {
                flashButton(btn, false);
            }
        } catch (e) {
            flashButton(btn, false);
        }
    }

    function flashButton(btn, success) {
        const originalText = "ENTER";
        
        if (success) {
            btn.style.backgroundColor = "#4CAF50"; 
            btn.style.borderColor = "#4CAF50";
            btn.innerText = "VALID";
        } else {
            btn.style.backgroundColor = "#ff4444"; 
            btn.style.borderColor = "#ff4444";
            btn.innerText = "INVALID";
        }

        setTimeout(() => {
            btn.style.backgroundColor = ""; 
            btn.style.borderColor = "";
            btn.innerText = originalText;
        }, 2000);
    }

    function toggleGuide() {
        const guide = document.getElementById('guide');
        const btn = document.querySelector('.how-to-toggle');
        if (getComputedStyle(guide).display === 'none') {
            guide.style.display = 'block';
            btn.innerText = '[ CLOSE GUIDE ]';
        } else {
            guide.style.display = 'none';
            btn.innerText = '[ HOW TO USE ]';
        }
    }

    function clearHistory() {
        conversationHistory = [];
        const container = document.getElementById('chatContainer');
        container.innerHTML = '<div class="msg system">Memory Cleared. Starting fresh session.</div>';
        const promptInput = document.getElementById('prompt');
        promptInput.placeholder = "Describe the music (Instruments, Key, Duration, Vibe)...";
    }

    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess().then(access => {
            const outputs = Array.from(access.outputs.values());
            const select = document.getElementById('midiOut');
            select.innerHTML = '';
            
            if (outputs.length === 0) {
                select.innerHTML = '<option value="">No Ports Found</option>';
                return;
            }

            outputs.forEach(port => {
                const option = document.createElement('option');
                option.value = port.id;
                option.text = port.name;
                if (port.name.toLowerCase().includes("iac") || 
                    port.name.toLowerCase().includes("loop")) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            updatePort();
            select.addEventListener('change', updatePort);
        }).catch(e => appendMsg("system error", "MIDI Access Denied: " + e));
    }

    function updatePort() {
        const id = document.getElementById('midiOut').value;
        if (!id) return;
        navigator.requestMIDIAccess().then(a => {
            midiOutput = a.outputs.get(id);
            if (midiOutput) appendMsg("system", `Connected to: ${midiOutput.name}`);
        });
    }

    function appendMsg(role, text) {
        const container = document.getElementById('chatContainer');
        const div = document.createElement('div');
        div.className = `msg ${role}`;
        div.innerText = text;
        container.appendChild(div);
        
        if (role === 'model') {
            if (div.previousElementSibling) {
                div.previousElementSibling.scrollIntoView({ behavior: "smooth", block: "start" });
            } else {
                div.scrollIntoView({ behavior: "smooth", block: "start" });
            }
        } 
       
        else if (role === 'system' && div.previousElementSibling && div.previousElementSibling.classList.contains('model')) {
        }
        else {
            container.scrollTop = container.scrollHeight;
        }
    }

    function panic() {
        if (!midiOutput) return;
        for (let ch = 0; ch < 16; ch++) {
            midiOutput.send([0xB0 + ch, 123, 0]); 
            midiOutput.send([0xB0 + ch, 120, 0]);
            midiOutput.send([0xB0 + ch, 64, 0]);
        }
    }

    function handleButtonClick() {
        if (isPlaying) {
            stopPlayback();
        } else {
            generateMusic();
        }
    }

    function stopPlayback() {
        isPlaying = false;
        
        if (schedulerTimerId) clearTimeout(schedulerTimerId);
        if (finishTimeoutId) clearTimeout(finishTimeoutId);
        schedulerTimerId = null;
        finishTimeoutId = null;

    
        panic();
        setTimeout(panic, 150);
        appendMsg("system", "Playback Stopped by User.");

        const btn = document.getElementById('generateBtn');
        btn.innerText = "GENERATE";
        btn.classList.remove('stop-mode');
        btn.disabled = false;
    }

    function startLoading() {
        let dots = 0;
        const btn = document.getElementById('generateBtn');
        btn.disabled = true;
        
        loadingInterval = setInterval(() => {
            dots = (dots + 1) % 4; 
            let text = "COMPOSING";
            for(let i=0; i<dots; i++) text += ".";
            btn.innerText = text;
        }, 400); 
    }

    function stopLoading(success = false) {
        clearInterval(loadingInterval);
        const btn = document.getElementById('generateBtn');
        
        if (success) {
            btn.innerText = "SUCCESS!";
            btn.style.backgroundColor = "#4CAF50"; 
            btn.style.borderColor = "#4CAF50";
            
            setTimeout(() => {
                if(isPlaying) {
                    btn.innerText = "STOP";
                    btn.style.backgroundColor = ""; 
                    btn.style.borderColor = "";
                    btn.classList.add('stop-mode');
                    btn.disabled = false; 
                }
            }, 2000); 
        } else {
            btn.innerText = "GENERATE";
            btn.disabled = false;
        }
    }

    async function generateMusic() {
        const key = document.getElementById('apiKey').value.trim();
        const promptInput = document.getElementById('prompt');
        const userPrompt = promptInput.value.trim();
        
        if (!key) return appendMsg("system error", "Please enter API Key.");
        if (!midiOutput) return appendMsg("system error", "Select MIDI Output.");
        if (!userPrompt) return;

        appendMsg("user", userPrompt);
        promptInput.value = ""; 
        promptInput.placeholder = "Ask for changes...";

        startLoading();

        conversationHistory.push({
            role: "user",
            parts: [{ text: userPrompt }]
        });

        const systemInstruction = `
        You are a Virtuosic MIDI Composer with a massive token budget.
        
        STEP 1: CREATIVE PLAN (REQUIRED)
        Before writing any JSON, you must explain your musical approach. 
        - Describe the rhythmic interaction between channels.
        - Explain how you will avoid repetition (e.g. "I will introduce a new motif at bar 4").
        - Explain how you will ensure the piece lasts the full requested duration.
        
        STEP 2: MIDI DATA
        Output the MIDI data in valid JSON. 
        - DO NOT put comments inside the JSON code block.
        - CRITICAL: Do not simply loop 1 bar. You must write unique variations.
        - CRITICAL: Ensure the last note ends at or after the requested duration.
        - HUMAN FEEL: You are NOT bound to a grid. Use micro-timing (e.g., start_time=1.05 instead of 1.00) for "swing" or "rubato" feels if the prompt requests it.
        - Format: { "tracks": [ { "channel": 1-16, "notes": [ { "pitch": 60, "velocity": 100, "start_time": 0.0, "duration": 1.0 } ] } ] }
        `;

        const payload = {
            system_instruction: {
                parts: [{ text: systemInstruction }]
            },
            contents: conversationHistory
        };

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error.message || "API Error");
            }

            const data = await response.json();

            if (data.usageMetadata) {
                const tokens = data.usageMetadata.candidatesTokenCount;
                appendMsg("system", `Generated ${tokens} tokens.`);
            }

            const candidateParts = data.candidates[0].content.parts;
            const rawText = candidateParts.map(p => p.text || "").join("");
            
            conversationHistory.push({
                role: "model",
                parts: candidateParts 
            });

            const jsonMatch = rawText.match(/\{[\s\S]*\}/);
            
            if (jsonMatch) {
                const jsonIndex = rawText.indexOf(jsonMatch[0]);
                let thoughts = rawText.substring(0, jsonIndex).trim();
                thoughts = thoughts.replace(/```json/g, "").replace(/```/g, "").trim();

                if (thoughts) {
                    appendMsg("model", thoughts); 
                }
                
                // THREADED PARSING via Worker
                processingWorker.postMessage(jsonMatch[0]);
                
            } else {
                appendMsg("model", rawText);
                throw new Error("Model generated text but no valid MIDI JSON.");
            }

        } catch (e) {
            appendMsg("system error", e.message);
            stopLoading(false);
            isPlaying = false;
        }
    }

    async function playSequence(events, maxDuration) {
        if (!audioContext) {
            audioContext = new AudioContext();
        }

        if (audioContext.state === "suspended") {
            await audioContext.resume();
        }

        if (schedulerTimerId) clearTimeout(schedulerTimerId);
        if (finishTimeoutId) clearTimeout(finishTimeoutId);
        schedulerTimerId = null;
        finishTimeoutId = null;

        if (!events || events.length === 0) return;

        const sequenceStartTime = audioContext.currentTime;
        let nextEventIndex = 0;

        const scheduleEvents = () => {
            if (!isPlaying || !midiOutput) return;

            const currentTime = audioContext.currentTime;
            const scheduleUntil = currentTime + SCHEDULE_AHEAD_TIME;

            while (nextEventIndex < events.length && events[nextEventIndex].time <= scheduleUntil - sequenceStartTime) {
                const event = events[nextEventIndex];
                
                const eventTime = sequenceStartTime + event.time;
                const deltaTime = Math.max(0, eventTime - currentTime);
                const timestamp = performance.now() + deltaTime * 1000;
                
                midiOutput.send(event.message, timestamp);
                nextEventIndex += 1;
            }

            if (nextEventIndex < events.length) {
                schedulerTimerId = setTimeout(scheduleEvents, LOOKAHEAD_MS);
            }
        };

        scheduleEvents();

        appendMsg("system", `Playing ${maxDuration.toFixed(1)}s sequence...`);

        const finishDelayMs = Math.max(0, (sequenceStartTime + maxDuration - audioContext.currentTime) * 1000);
        
        finishTimeoutId = setTimeout(() => {
            appendMsg("system", "Playback Finished.");
            
        
            panic();
            setTimeout(panic, 150); 

            const btn = document.getElementById('generateBtn');
            btn.innerText = "GENERATE";
            btn.classList.remove('stop-mode');
            btn.disabled = false; 
            isPlaying = false;
            schedulerTimerId = null;
            finishTimeoutId = null;
        }, finishDelayMs + 200); 
    }
</script>
</body>
</html>
